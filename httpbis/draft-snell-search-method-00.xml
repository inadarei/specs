<?xml version="1.0"?> 
<!DOCTYPE rfc SYSTEM "rfc2629.dtd" [ 
  <!ENTITY rfc2119 PUBLIC '' 'http://xml.resource.org/public/rfc/bibxml/reference.RFC.2119.xml'>
  <!ENTITY rfc2068 PUBLIC '' 'http://xml.resource.org/public/rfc/bibxml/reference.RFC.2068.xml'>
  <!ENTITY rfc5323 PUBLIC '' 'http://xml.resource.org/public/rfc/bibxml/reference.RFC.5323.xml'>
  <!ENTITY rfc4918 PUBLIC '' 'http://xml.resource.org/public/rfc/bibxml/reference.RFC.4918.xml'>
  <!ENTITY part1 PUBLIC '' 'http://xml.resource.org/public/rfc/bibxml/reference.RFC.7230.xml'>
  <!ENTITY part2 PUBLIC '' 'http://xml.resource.org/public/rfc/bibxml/reference.RFC.7231.xml'>
  <!ENTITY part6 PUBLIC '' 'http://xml.resource.org/public/rfc/bibxml/reference.RFC.7234.xml'>
  <!ENTITY part4 PUBLIC '' 'http://xml.resource.org/public/rfc/bibxml/reference.RFC.7232.xml'>
]>
<?rfc toc="yes"?> 
<?rfc strict="yes"?> 
<?rfc symrefs="yes" ?> 
<?rfc sortrefs="yes"?> 
<?rfc compact="yes"?> 
<rfc category="std" ipr="trust200811" docName="draft-snell-search-method-00"> 
  <front> 
    <title abbrev="HTTP SEARCH Method"> 
      HTTP SEARCH Method
    </title> 
 
    <author initials="J." surname="Reschke" fullname="Julian Reschke">
      <address>
        <email>julian.reschke@gmx.de</email>
      </address>
    </author>
    <author initials="A." surname="Malhotra" fullname="Ashok Malhotra">
      <address>
        <email>ashok.malhotra@oracle.com</email>
      </address>
    </author>
     <author initials="J.M." surname="Snell" fullname="James M Snell"> 
      <address> 
        <email>jasnell@gmail.com</email> 
      </address> 
    </author> 

    <date month="January" year="2015" /> 
 
    <area>Applications</area> 
    <workgroup>Individual Submission</workgroup> 
    <keyword>I-D</keyword> 
    <keyword>http</keyword>
    <keyword>search</keyword>
    <keyword>method</keyword>
 
    <abstract> 
      <t>
        This specification updates the definition and semantics of the 
        HTTP SEARCH request method previously defined by <xref target="RFC5323" />.
      </t> 
    </abstract> 
 
  </front> 
  
  <middle> 

  <section anchor="intro" title="Introduction"> 

    <t>
      This specification updates the HTTP SEARCH method originally
      defined in <xref target="RFC5323"/>.
    </t>
  
    <t>
      In this document, the key words "MUST", "MUST NOT", "REQUIRED", "SHALL", 
      "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" 
      are to be  interpreted as described in <xref target="RFC2119" />.
    </t> 

  </section> 
  
  <section title="Rationale" anchor="rationale">
    <t>TBD</t>
  </section>
  
  <section title="SEARCH" anchor="search">
  
    <t>
      The SEARCH method is used to initiate a server-side search.
    </t>

    <t>
      The effective request URI (as defined by <xref target="RFC7230"/>) 
      identifies the "search arbiter". The arbiter can be any HTTP resource 
      capable of performing the requested search. The SEARCH method defines 
      no relationship between this arbiter and the scope of the search; rather, 
      the particular query grammar used in the query defines the relationship. 
      For example a query grammar can force the effective request URI to 
      correspond exactly to the search scope.
    </t>

    <t>
      The body of the request defines the query. Implementations MAY use 
      a request body of any content type with the SEARCH method; however,
      for backwards compatibility with existing WebDAV implementations,  
      SEARCH requests that use the text/xml or application/xml content types
      MUST be processed in exact accordance with the requirements established by 
      <xref target="RFC5323" />. 
    </t>

    <t>
      SEARCH requests are both safe and idempotent. The performance of a 
      search is not expected to alter the state of the search arbiter identified 
      by the effective request URI; however, while performing a search, the arbiter 
      can be expected to allocate computing and memory resources or even create 
      additional HTTP resources through which the response to the search 
      can be retrieved. 
    </t>

    <t>
      A successful response to a SEARCH request is expected to provide some 
      indication as to the final disposition of the search operation. For instance,
      a successful search that yields no results can be represented by a 204 No Content
      response. If the response includes a body payload, the payload is expected
      to describe the results of the search operation. In some cases, the search
      arbiter might choose to respond indirectly to the SEARCH request by returning
      a 3xx Redirection with a Location header specifying an alternate Request URI 
      from which the search results can be retrieved by using an HTTP GET request. 
      Various non-normative examples of successful SEARCH responses are illustrated 
      in <xref target="examples" />.
    </t>

    <t>
      The response to a SEARCH request is not cacheable. It ought to be noted,
      however, that because SEARCH requests are safe and idempotent, responses 
      to a SEARCH SHOULD NOT invalidate previously cached responses to other 
      requests directed at the same effective request URI.
    </t>

    <t>
      The semantics of the SEARCH method change to a "conditional SEARCH" if
      the request message includes an If-Modified-Since, If-Unmodified-
      Since, If-Match, If-None-Match, or If-Range header field
      (<xref target="RFC7232"/>).  A conditional 
      SEARCH requests that the query be performed only under the 
      circumstances described by the conditional header field(s).
    </t>
    
  </section>

  <section title="The &quot;Accept-Search&quot; Header Field" anchor="accept-search">
    <t>TBD</t>
  </section>
  
  <section title="Relationship to other HTTP Methods">
    <t>TBD</t>
  </section>

  <section title="Examples" anchor="examples">
  
    <section title="Simple SEARCH with a Direct Response">
<figure><preamble>A simple SPAQRL query with a Direct Response:</preamble><artwork><![CDATA[
SEARCH /query HTTP/1.1
Host: example.org
Content-Type: application/sparql-query
Accept: application/ld+json

PREFIX foaf:  <http://xmlns.com/foaf/0.1/>
SELECT ?name ?email
FROM <http://www.w3.org/People/Berners-Lee/card>
WHERE {
    ?person foaf:name ?name .
    OPTIONAL { ?person foaf:mbox ?email }
} ORDER BY ?name LIMIT 10 OFFSET 10
]]></artwork></figure>

<figure><preamble>Response:</preamble><artwork><![CDATA[
TBD
]]></artwork></figure>

    </section>

    <section title="Simple SEARCH with Indirect Response (303 See Other)">
<figure><preamble>A simple SPAQRL query with an Indirect Response (303 See Other)</preamble><artwork><![CDATA[
SEARCH /query HTTP/1.1
Host: example.org
Content-Type: application/sparql-query
Accept: application/ld+json

PREFIX foaf:  <http://xmlns.com/foaf/0.1/>
SELECT ?name ?email
FROM <http://www.w3.org/People/Berners-Lee/card>
WHERE {
    ?person foaf:name ?name .
    OPTIONAL { ?person foaf:mbox ?email }
} ORDER BY ?name LIMIT 10 OFFSET 10
]]></artwork></figure>

<figure><preamble>Response:</preamble><artwork><![CDATA[
HTTP/1.1 303 See Other
Location: http://example.org/query123res
]]></artwork></figure>

<figure><preamble>Fetch Query Response:</preamble><artwork><![CDATA[
GET /query123res HTTP/1.1
Host: example.org
]]></artwork></figure>

<figure><preamble>Response:</preamble><artwork><![CDATA[
TBD
]]></artwork></figure>

    </section>

    <section title="Possible approach for a &quot;Stored Query&quot;">

      <t>
        "Stored Queries" are one possible way that a server can 
        implement SEARCH. Essentially, a client would first create 
        a resource representing a parameterized query using either
        PUT or POST, then would invoke the query using a SEARCH 
        request.
      </t>

<figure><preamble>A simple SPAQRL query with an Indirect Response (303 See Other)</preamble><artwork><![CDATA[
POST /queries HTTP/1.1
Host: example.org
Content-Type: application/sparql-query
Accept: application/ld+json
Slug: Query A

PREFIX foaf:  <http://xmlns.com/foaf/0.1/>
SELECT ?name ?email
FROM <http://www.w3.org/People/Berners-Lee/card>
WHERE {
    ?person foaf:name ?name .
    OPTIONAL { ?person foaf:mbox ?email }
} ORDER BY ?name LIMIT 10 OFFSET 10
]]></artwork></figure> 

<figure><preamble>Response:</preamble><artwork><![CDATA[
HTTP/1.1 201 Created
Location: /queries/query-a
Accept-Query: application/x-www-form-urlencoded
]]></artwork></figure>

<figure><preamble>The SEARCH Request:</preamble><artwork><![CDATA[
SEARCH /queries/query-a HTTP/1.1
Host: example.org
Content-Type: application/x-www-form-urlencoded

email=sam%40example.org
]]></artwork></figure>
 
      <t>
        The response to the SEARCH would return the results of executing
        the query operation using the specified input parameter. In contrast,
        performing a GET request on the resource would return the definition
        of the stored query itself:
      </t>

<figure><preamble>The SEARCH Request:</preamble><artwork><![CDATA[
GET /queries/query-a HTTP/1.1
Host: example.org
]]></artwork></figure>

<figure><preamble>GET Response:</preamble><artwork><![CDATA[
HTTP/1.1 200 OK
Content-Type: application/sparql-query

PREFIX foaf:  <http://xmlns.com/foaf/0.1/>
SELECT ?name ?email
FROM <http://www.w3.org/People/Berners-Lee/card>
WHERE {
    ?person foaf:name ?name .
    OPTIONAL { ?person foaf:mbox ?email }
} ORDER BY ?name LIMIT 10 OFFSET 10
]]></artwork></figure> 

    </section>

  </section>

  <section title="Discussion Notes">
    <t>Ed. Note: Remove this section before publication</t>

    <t>
      <list style="symbols">
        <t>
          The 'Accept-Search' header field ought to be considered to signal a server's support for search.
          It's use would be equivalent to that of Accept-Patch and Accept-Post... that is, to indicate
          the specific query data formats supported by a resource.
        </t>
        <t>
          Result-set truncation and paging ought to be considered. Many query string based APIs support
          offset, limit, page or bookmark based truncation of results. Do we want to require specific 
          query formats to define their own truncation/paging within the query language (e.g. SPARQL's 
          limit and offset) or is there value in providing a generalized HTTP Range header based 
          mechanism (e.g. "Range: offset=0-10" to indicate returning ten results starting at offset 0, or
          "Range: page=1" to indicate returning the first page of results, etc.) 
        </t>
      </list>
    </t>
  </section>

  <section title="Security Considerations">
    <t>
      The SEARCH method is subject to the same general security 
      considerations as all HTTP methods as described in 
      <xref target="RFC7231"/>.
    </t>    
  </section>

  <section title="IANA Considerations">
    
    <t>
      IANA is requested to update the registration of the SEARCH method in the 
      permanent registry at &lt;http://www.iana.org/assignments/http-methods&gt;
      (see Section 8.1 of <xref target="RFC7231" />).
    </t>
    
    <texttable>
      <ttcol>Method Name</ttcol>
      <ttcol>Safe</ttcol>
      <ttcol>Idempotent</ttcol>
      <ttcol>Specification</ttcol>
      
      <c>SEARCH</c>
      <c>Yes</c>
      <c>Yes</c>
      <c><xref target="search"/></c>
      
    </texttable>
    
  </section>
  
</middle>
<back>
  <references title="Normative References"> 
    &rfc2119;
    &rfc5323;
    &rfc4918;
    &part1;
    &part2;
    &part4;
    &part6;
  </references>
</back>
</rfc> 
 